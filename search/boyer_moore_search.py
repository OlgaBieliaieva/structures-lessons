def build_shift_table(pattern):
  """Створити таблицю зсувів для алгоритму Боєра-Мура."""
  table = {}
  length = len(pattern)
  # Для кожного символу в підрядку встановлюємо зсув рівний довжині підрядка
  for index, char in enumerate(pattern[:-1]):
    table[char] = length - index - 1
  # Якщо символу немає в таблиці, зсув буде дорівнювати довжині підрядка
  table.setdefault(pattern[-1], length)
  return table

def boyer_moore_search(text, pattern):
  # Створюємо таблицю зсувів для патерну (підрядка)
  shift_table = build_shift_table(pattern)
  i = 0 # Ініціалізуємо початковий індекс для основного тексту

  # Проходимо по основному тексту, порівнюючи з підрядком
  while i <= len(text) - len(pattern):
    j = len(pattern) - 1 # Починаємо з кінця підрядка

    # Порівнюємо символи від кінця підрядка до його початку
    while j >= 0 and text[i + j] == pattern[j]:
      j -= 1 # Зсуваємось до початку підрядка

    # Якщо весь підрядок збігається, повертаємо його позицію в тексті
    if j < 0:
      return i # Підрядок знайдено

    # Зсуваємо індекс i на основі таблиці зсувів
    # Це дозволяє "перестрибувати" над неспівпадаючими частинами тексту
    i += shift_table.get(text[i + len(pattern) - 1], len(pattern))

  # Якщо підрядок не знайдено, повертаємо -1
  return -1

text = "Being a developer is not easy"
pattern = "developer"

position = boyer_moore_search(text, pattern)
if position != -1:
  print(f"Substring found at index {position}")
else:
  print("Substring not found")


# У найкращому випадку алгоритм Боєра-Мура може мати лінійну часову складність O(n)O(n), де nn — це довжина тексту. 
# Це досягається, коли жоден символ підрядка не збігається з символами тексту, 
# змушуючи алгоритм робити максимальний можливий зсув при кожній невдалій спробі знаходження збігу.


# Однак у найгіршому випадку, особливо коли символи підрядка часто зустрічаються в тексті, 
# але сам підрядок не знаходиться, часова складність може досягти O(n⋅m)O(n⋅m), де mm — це довжина підрядка.


# У загальному випадку алгоритм Боєра-Мура, завдяки своїй стратегії зсуву, 
# часто виявляється швидшим у порівнянні з багатьма іншими алгоритмами пошуку.